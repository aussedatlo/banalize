import { readFileSync, writeFileSync, mkdirSync } from "fs";
import { join } from "path";

const protoPath = join(process.cwd(), "proto/banalize.proto");
const distPath = join(process.cwd(), "dist");
const indexPath = join(distPath, "index.ts");

// Read proto file
const protoContent = readFileSync(protoPath, "utf-8");

// Parse proto file and generate TypeScript types
function generateTypes(proto: string): string {
  // Extract message definitions manually based on the proto file structure
  // This is a simple approach - for production, consider using a proper proto parser
  
  let output = `// Auto-generated TypeScript types from proto files
// Field names use snake_case to match @grpc/proto-loader output (keepCase: true)
// DO NOT EDIT THIS FILE - it is generated from proto/banalize.proto

`;

  // Request types
  output += `// Request types
export interface AddConfigRequest {
  id: string;
  name: string;
  param: string;
  regex: string;
  ban_time: number;
  find_time: number;
  max_matches: number;
  ignore_ips: string[];
}

export interface EditConfigRequest {
  id: string;
  name?: string;
  param?: string;
  regex?: string;
  ban_time?: number;
  find_time?: number;
  max_matches?: number;
  ignore_ips?: string[];
}

export interface UnbanRequest {
  event_id: string;
  ip: string;
}

export type PingRequest = Record<string, never>;

export type ListConfigRequest = Record<string, never>;

export type ListCurrentBansRequest = Record<string, never>;

export type ListCurrentMatchesRequest = Record<string, never>;

export type StreamEventsRequest = Record<string, never>;

// Response types
export interface AddConfigResponse {
  success: boolean;
  error: string;
}

export interface EditConfigResponse {
  success: boolean;
  error: string;
}

export interface UnbanResponse {
  success: boolean;
  error: string;
}

export interface PingResponse {
  message: string;
}

export interface ConfigStatus {
  id: string;
  name: string;
  param: string;
  regex: string;
  ban_time: number;
  find_time: number;
  max_matches: number;
  ignore_ips: string[];
  running: boolean;
  error: string;
}

export interface ListConfigResponse {
  configs: ConfigStatus[];
}

export interface BanRecord {
  ip: string;
  timestamp: number;
}

export interface ListCurrentBansResponse {
  bans: BanRecord[];
}

export interface MatchRecord {
  config_id: string;
  ip: string;
  timestamp: number;
}

export interface ListCurrentMatchesResponse {
  matches: MatchRecord[];
}

// Event types
export interface MatchEvent {
  event_id: string;
  line: string;
  regex: string;
  ip: string;
  timestamp: number;
  config_id: string;
}

export interface BanEvent {
  event_id: string;
  ip: string;
  timestamp: number;
  config_id: string;
}

export interface UnbanEvent {
  event_id: string;
  ip: string;
  timestamp: number;
  config_id: string;
}

export interface Event {
  match?: MatchEvent;
  ban?: BanEvent;
  unban?: UnbanEvent;
}

// Client interfaces for @grpc/grpc-js compatibility
import type * as grpc from "@grpc/grpc-js";

export interface BanalizeCoreClient {
  addConfig(
    request: AddConfigRequest,
    callback: (
      error: grpc.ServiceError | null,
      response: AddConfigResponse,
    ) => void,
  ): void;
  editConfig(
    request: EditConfigRequest,
    callback: (
      error: grpc.ServiceError | null,
      response: EditConfigResponse,
    ) => void,
  ): void;
  unban(
    request: UnbanRequest,
    callback: (
      error: grpc.ServiceError | null,
      response: UnbanResponse,
    ) => void,
  ): void;
  ping(
    request: PingRequest,
    callback: (
      error: grpc.ServiceError | null,
      response: PingResponse,
    ) => void,
  ): void;
  listConfig(
    request: ListConfigRequest,
    callback: (
      error: grpc.ServiceError | null,
      response: ListConfigResponse,
    ) => void,
  ): void;
  listCurrentBans(
    request: ListCurrentBansRequest,
    callback: (
      error: grpc.ServiceError | null,
      response: ListCurrentBansResponse,
    ) => void,
  ): void;
  listCurrentMatches(
    request: ListCurrentMatchesRequest,
    callback: (
      error: grpc.ServiceError | null,
      response: ListCurrentMatchesResponse,
    ) => void,
  ): void;
}

export interface BanalizeEventsClient {
  streamEvents(
    request: StreamEventsRequest,
  ): grpc.ClientReadableStream<Event>;
}
`;

  return output;
}

// Main execution
try {
  const typesContent = generateTypes(protoContent);
  
  // Ensure dist directory exists
  try {
    mkdirSync(distPath, { recursive: true });
  } catch {
    // Directory might already exist
  }
  
  writeFileSync(indexPath, typesContent);
  console.log("âœ“ Generated TypeScript types from proto file");
} catch (error) {
  console.error("Error generating types:", error);
  process.exit(1);
}
